# Reading 3: Prompt Engineering Guide
# 提示工程实用指南

> **Week 1 Reading #3**
> **主题**: 实用的提示设计技巧、模板和案例
> **预计阅读时间**: 60-90 分钟

---

## 📚 导读

本文是提示工程的实用指南，提供：

1. **即用模板** - 可直接使用的提示词模板
2. **场景案例** - 针对具体任务的提示设计
3. **调优技巧** - 如何优化提示效果
4. **常见问题** - FAQ 和故障排除

---

## 🎯 学习目标

阅读完本文后，你应该能够：

- ✅ 使用 10+ 个即用提示词模板
- ✅ 为常见任务设计有效提示
- ✅ 诊断和修复提示问题
- ✅ 系统性地优化提示质量
- ✅ 建立个人提示词库

---

## 第一部分：提示词模板库

### 模板 1: 代码生成

#### 基础版本
```
请用 [编程语言] 实现以下功能：

【功能描述】
[清晰描述功能]

【输入】
- [参数1]: [类型和说明]
- [参数2]: [类型和说明]

【输出】
[返回值说明]

【要求】
1. [要求1]
2. [要求2]
3. [要求3]

【边界情况】
- [情况1]: 如何处理
- [情况2]: 如何处理
```

#### 完整版本
```
# 代码生成任务

## 角色设定
你是一位资深 [领域] 工程师，有 [年数] 年经验。

## 任务概述
[任务描述]

## 技术要求

### 语言和框架
- 语言: [编程语言] [版本]
- 框架: [框架名称] [版本]
- 依赖: 仅使用标准库 / 可使用 [特定库]

### 代码质量
- 遵循 [编码规范]
- 包含完整的类型注解
- 添加详细的文档字符串（Google/NumPy 风格）
- 代码注释解释关键逻辑

### 性能要求
- 时间复杂度不超过: [复杂度]
- 空间复杂度不超过: [复杂度]
- 针对数据规模: [具体规模]

## 功能规范

### 输入
```python
# 类型定义
[Type Hints]

# 示例输入
input_data = {
    "field1": "value1",
    "field2": 42,
}
```

### 输出
```python
# 返回类型
[Type Hints]

# 示例输出
output_data = {
    "result": "computed",
    "metadata": {...}
}
```

### 核心逻辑
1. [步骤1]
2. [步骤2]
3. [步骤3]

### 边界情况处理
- 空输入: [处理方式]
- 无效输入: [处理方式]
- 极端值: [处理方式]
- 错误情况: [处理方式]

## 输出格式

### 完整代码
```python
# -*- coding: utf-8 -*-
"""
[模块文档字符串]

该模块提供 [功能描述]

Example:
    >>> [使用示例]
"""

from typing import [类型导入]

def [函数名](
    param1: [类型],
    param2: [类型],
    *args,
    **kwargs
) -> [返回类型]:
    """
    [函数文档字符串]

    Args:
        param1: [参数说明]
        param2: [参数说明]

    Returns:
        [返回值说明]

    Raises:
        [异常]: [异常说明]

    Examples:
        >>> [示例]
    """
    # 实现
    pass


class [类名]:
    """[类文档字符串]"""

    def __init__(self, ...):
        """初始化"""
        pass

    def [方法名](self, ...):
        """[方法文档字符串]"""
        pass
```

### 测试代码
```python
import unittest

class Test[功能名](unittest.TestCase):
    """测试 [功能名]"""

    def test_normal_case(self):
        """测试正常情况"""
        # Arrange
        input = [...]
        expected = [...]

        # Act
        result = [函数名](input)

        # Assert
        self.assertEqual(result, expected)

    def test_edge_cases(self):
        """测试边界情况"""
        # 测试空输入
        self.assertIsNone([函数名](None))

        # 测试极端值
        self.assertEqual([函数名](99999), ...)

    def test_error_handling(self):
        """测试错误处理"""
        with self.assertRaises(ValueError):
            [函数名](invalid_input)

if __name__ == "__main__":
    unittest.main()
```

### 性能测试（如需要）
```python
import timeit

def benchmark():
    """性能测试"""
    setup = """
from [模块] import [函数名]
data = [测试数据]
    """

    stmt = "[函数名](data)"

    iterations = 1000
    time_taken = timeit.timeit(stmt, setup, number=iterations)

    print(f"平均执行时间: {time_taken/iterations*1000:.2f} ms")
    print(f"吞吐量: {iterations/time_taken:.2f} ops/sec")

if __name__ == "__main__":
    benchmark()
```

## 参考实现

如果需要，可以参考以下模式：

### [相关代码示例]
```python
[示例代码]
```

### 设计模式
建议使用: [设计模式名称]

原因: [为什么使用这个模式]
```

### 使用示例

**场景**: 生成一个用户认证函数

```
# 代码生成任务

## 角色设定
你是一位资深 Python 后端工程师，有 8 年 Web 开发经验。

## 任务概述
实现一个安全的用户密码哈希和验证函数。

## 技术要求

### 语言和框架
- 语言: Python 3.12+
- 框架: 仅使用标准库
- 可使用: hashlib, secrets, os

### 代码质量
- 遵循 PEP 8 规范
- 包含完整的类型注解
- 添加详细的文档字符串（Google 风格）
- 代码注释解释安全考虑

### 安全要求
- 使用强哈希算法（SHA-256 或更好）
- 每个密码使用唯一的盐值
- 常量时间比较（防止时序攻击）
- 最小密码长度要求

## 功能规范

### 输入
```python
password: str  # 用户密码，明文
```

### 输出
```python
# 哈希密码
hashed: str  # 格式: "algorithm$salt$hash"

# 验证结果
is_valid: bool  # True/False
```

### 核心逻辑
1. 生成随机盐值（16 字节）
2. 使用盐值哈希密码
3. 存储格式: "sha256$salt$hash"
4. 验证时提取盐值并重新哈希

### 边界情况处理
- 空密码: 拒绝（ValueError）
- 短密码（<8 字符）: 拒绝（ValueError）
- 无效哈希格式: 验证失败（返回 False）
```

---

### 模板 2: 代码审查

```
# 代码审查请求

## 审查重点
请关注以下方面（按优先级排序）：

### 1. 安全性 [最高优先级]
- [ ] SQL 注入风险
- [ ] XSS 漏洞
- [ ] CSRF 保护
- [ ] 敏感数据泄露
- [ ] 权限检查缺失
- [ ] 不安全的随机数生成
- [ ] 硬编码的密钥/密码

### 2. 正确性
- [ ] 逻辑错误
- [ ] 边界情况未处理
- [ ] 错误处理不当
- [ ] 类型不匹配
- [ ] 空值/None 处理

### 3. 性能
- [ ] 明显的性能瓶颈
- [ ] N+1 查询问题
- [ ] 不必要的内存使用
- [ ] 可以优化的算法

### 4. 可维护性
- [ ] 命名不清晰
- [ ] 过长的函数（>50 行）
- [ ] 重复代码
- [ ] 魔法数字/字符串
- [ ] 缺少文档

## 待审查代码

### 文件: [文件路径]
```python
[代码内容]
```

### 上下文
- 项目类型: [Web/数据/脚本等]
- 技术栈: [框架和主要库]
- 代码目的: [简述功能]

## 审查要求

### 输出格式
请按以下格式提供审查报告：

```markdown
# 代码审查报告

## 严重问题（必须修复）
### [问题标题]
- **位置**: [文件:行号]
- **类型**: [安全/正确性/性能]
- **风险**: [具体风险]
- **建议**: [如何修复]
- **示例**: [修复代码示例]

## 改进建议（推荐修复）
### [问题标题]
...

## 风格建议（可选）
### [问题标题]
...

## 正面反馈
- [做得好的地方]

## 总结
[整体评价和优先级建议]
```

### 审查标准
- **严重问题**: 安全漏洞、功能错误、性能严重问题
- **改进建议**: 代码质量、可维护性、最佳实践
- **风格建议**: 命名、格式、组织
```

---

### 模板 3: Bug 修复

```
# Bug 诊断和修复

## Bug 报告

### 错误现象
```
[错误信息的完整输出]
```

### 复现步骤
1. [步骤 1]
2. [步骤 2]
3. [步骤 3]
4. [观察到错误]

### 期望行为
[应该发生什么]

### 实际行为
[实际发生了什么]

### 相关代码

#### 文件 1: [文件路径]
```python
[代码片段 1]
```

#### 文件 2: [文件路径]
```python
[代码片段 2]
```

## 诊断要求

请按以下步骤诊断：

### 第一步: 理解错误
- 错误类型是什么？
- 错误消息的关键信息是什么？
- 堆栈跟踪指向哪里？

### 第二步: 分析根因
- 为什么会出现这个错误？
- 是逻辑错误、类型错误还是其他问题？
- 哪些代码路径导致了问题？

### 第三步: 提供修复方案
1. **修复方案** (最直接的方式)
   - 修改位置: [文件:行号]
   - 修改内容: [具体修改]
   - 为什么这样修复: [解释]

2. **替代方案** (如适用)
   - [方案描述]

### 第四步: 验证修复
- 如何验证修复有效？
- 需要什么测试用例？
- 是否有副作用？

### 第五步: 防止再次发生
- 这个 bug 的根本原因是什么？
- 如何在代码层面预防？
- 是否需要添加测试？
- 是否需要更新文档？

## 输出格式

```markdown
# Bug 诊断报告

## 问题分析
### 错误类型
[错误类型名称]

### 根本原因
[详细分析]

### 触发条件
[什么情况下触发]

## 修复方案

### 方案 1: [方案名称]
**修改位置**: `[文件名:行号]`

**当前代码**:
```python
[问题代码]
```

**修复后代码**:
```python
[修复代码]
```

**修复原因**: [为什么这样修复有效]

### 方案 2: [方案名称]
...

## 验证方案
### 测试用例
```python
[测试代码]
```

### 手动验证
1. [验证步骤 1]
2. [验证步骤 2]

## 预防措施
- [ ] 添加单元测试
- [ ] 添加类型检查
- [ ] 改进错误处理
- [ ] 更新文档
```
```

---

### 模板 4: 重构建议

```
# 代码重构请求

## 当前代码

### 文件: [文件路径]
```python
[待重构的代码]
```

## 代码问题

### 已知问题
1. [问题 1]
2. [问题 2]
3. [问题 3]

### 代码异味（Code Smell）
- [ ] 过长函数
- [ ] 过长类
- [ ] 重复代码
- [ ] 过长参数列表
- [ ] 特性依恋（Feature Envy）
- [ ] 数据泥团（Data Clumps）
- [ ] 基本类型偏执（Primitive Obsession）

## 重构目标

### 功能要求
- **必须**: 保持原有功能不变
- **必须**: 所有现有测试通过
- **必须**: 不改变公共接口（除非明确说明）

### 质量要求
- **可读性**: 代码更易理解
- **可维护性**: 更容易修改和扩展
- **可测试性**: 更容易测试
- **性能**: 不低于原实现（或说明权衡）

### 具体改进
1. [改进目标 1]
2. [改进目标 2]
3. [改进目标 3]

## 重构建议

请提供：

### 方案概述
[简要描述重构策略]

### 重构步骤
1. **[步骤 1 名称]**
   - 操作: [具体操作]
   - 原因: [为什么这样做]

2. **[步骤 2 名称]**
   - 操作: [具体操作]
   - 原因: [为什么这样做]

...

### 重构后代码
```python
# 文件结构
[目录结构]

# 主要文件
[重构后的代码]

# 测试代码
[需要的测试]
```

### 对比分析
| 维度 | 重构前 | 重构后 | 改进 |
|------|--------|--------|------|
| 代码行数 | | | |
| 圈复杂度 | | | |
| 可读性 | | | |
| 可测试性 | | | |
| 性能 | | | |

### 迁移指南
如果接口有变化，提供迁移步骤：
```python
# 旧代码
[旧用法]

# 新代码
[新用法]
```

## 风险评估
- [ ] 高风险: [风险描述]
- [ ] 中风险: [风险描述]
- [ ] 低风险: [风险描述]
```

---

### 模板 5: 文档生成

```
# 文档生成任务

## 文档类型
- [ ] README
- [ ] API 文档
- [ ] 用户指南
- [ ] 开发者文档
- [ ] 架构文档
- [ ] 教程

## 项目信息

### 项目概述
```
名称: [项目名]
描述: [一句话描述]
目的: [解决什么问题]
```

### 技术栈
- 语言: [编程语言] [版本]
- 框架: [框架名称]
- 数据库: [数据库类型]
- 其他: [其他重要依赖]

### 项目结构
```
project/
├── src/
│   ├── module1/
│   └── module2/
├── tests/
├── docs/
└── README.md
```

## 文档要求

### 目标受众
- [ ] 终端用户
- [ ] 开发者
- [ ] 贡献者
- [ ] 运维人员

### 文档风格
- 语言: [中文/英文]
- 语调: [正式/友好/技术]
- 格式: Markdown / reStructuredText

### 包含内容

#### 必需章节
1. [ ] 项目介绍
2. [ ] 快速开始
3. [ ] 安装说明
4. [ ] 基本用法
5. [ ] 配置说明

#### 可选章节
6. [ ] 高级用法
7. [ ] API 参考
8. [ ] 常见问题
9. [ ] 贡献指南
10. [ ] 许可证

## 输出格式

```markdown
# [项目名称]

[项目 Logo]

[项目标语]

## 简介
[项目概述 2-3 段]

## 特性
- ✨ [特性 1]
- 🚀 [特性 2]
- 🔒 [特性 3]
- 📦 [特性 4]

## 快速开始

### 安装
\`\`\`bash
# 使用 pip
pip install [package-name]

# 使用 conda
conda install -c conda-forge [package-name]

# 从源码安装
git clone https://github.com/[user]/[repo].git
cd [repo]
pip install -e .
\`\`\`

### Hello World
\`\`\`python
import [package-name]

# 基本用法示例
[示例代码]
\`\`\`

## 文档

### 用户指南
- [入门教程](docs/tutorial.md)
- [使用指南](docs/guide.md)
- [最佳实践](docs/best-practices.md)

### API 文档
- [完整 API 参考](docs/api.md)
- [示例代码](examples/)

## 常见问题

### Q: [问题]
**A**: [答案]

### Q: [问题]
**A**: [答案]

## 贡献
欢迎贡献！请阅读 [贡献指南](CONTRIBUTING.md)。

## 许可证
[许可证名称] - 详见 [LICENSE](LICENSE) 文件

## 联系方式
- 作者: [作者名]
- 邮箱: [email]
- 网站: [URL]
```
```

---

## 第二部分：场景案例

### 案例 1: 从需求生成代码

**场景**: 产品经理提供一个功能需求

**输入提示**:
```
# 功能开发任务

## 需求描述
实现一个用户评论系统，支持：
1. 用户发表评论
2. 评论点赞/点踩
3. 评论回复（嵌套）
4. 评论排序（热度/时间）
5. 评论过滤（敏感词）

## 技术背景

### 项目信息
- 类型: Django REST API
- Python: 3.12
- Django: 4.2
- 数据库: PostgreSQL 15
- 缓存: Redis 7.0

### 现有模型
```python
# 已有的 User 模型
class User(AbstractUser):
    nickname = models.CharField(max_length=50)
    avatar = models.URLField()
```

## 数据模型设计

请设计以下模型：
1. Comment（评论）
2. CommentLike（评论点赞）
3. SensitiveWord（敏感词）

要求：
- 软删除（is_deleted 标记）
- 时间戳（created_at, updated_at）
- 索引优化
- 数据验证

## API 端点

需要实现的 API：
1. POST /api/comments/ - 发表评论
2. GET /api/comments/{id}/ - 获取评论详情
3. PUT /api/comments/{id}/ - 修改评论
4. DELETE /api/comments/{id}/ - 删除评论
5. POST /api/comments/{id}/like/ - 点赞
6. POST /api/comments/{id}/dislike/ - 点踩
7. GET /api/comments/{id}/replies/ - 获取回复列表
8. POST /api/comments/{id}/replies/ - 回复评论

## 业务逻辑

### 发表评论
- 验证用户登录
- 检查敏感词
- 验证内容长度（1-1000 字符）
- 验证父评论存在（如果是回复）
- 记录 IP 和 User-Agent

### 评论排序
- 热度排序: likes - dislikes * 2
- 时间排序: 最新的在前

### 敏感词过滤
- 完全匹配: 替换为 ***
- 模糊匹配: 拒绝发布

### 权限控制
- 只有作者可以修改/删除
- 登录用户才能点赞
- 防止重复点赞

## 性能要求

### 响应时间
- 发表评论: < 200ms
- 获取评论列表: < 100ms (每页 20 条)

### 并发处理
- 支持 1000 评论/秒
- 使用 Redis 缓存热门评论

## 输出要求

请按以下顺序提供：

### 1. 数据模型
完整的 models.py 代码，包括：
- 字段定义
- Meta 配置
- 方法（__str__, save 等）

### 2. 序列化器
serializers.py 代码

### 3. 视图
views.py 代码（使用 ViewSet）

### 4. URL 配置
urls.py 代码

### 5. 迁移文件
生成迁移的命令

### 6. 测试用例
关键功能的单元测试

### 7. 性能优化建议
- 数据库索引
- 缓存策略
- 查询优化
```

---

### 案例 2: 调试复杂错误

**场景**: 生产环境的偶发错误

**输入提示**:
```
# 生产环境问题诊断

## 错误信息

### 日志输出
```
2025-01-15 14:32:18 ERROR [app.api.views:234] Internal Server Error
Traceback (most recent call last):
  File "/app/api/views.py", line 234, in process_order
    result = payment_service.charge(user, amount)
  File "/app/services/payment.py", line 89, in charge
    response = self._api_call(endpoint, data)
  File "/app/services/payment.py", line 156, in _api_call
    raise PaymentError(f"API error: {response.status_code}")
app.exceptions.PaymentError: API error: 503

Request: POST /api/orders/123/process
User: user_45678
Amount: $99.99
```

### 复现模式
- **频率**: 约 1% 的订单失败
- **时间**: 无规律，全天都可能发生
- **用户**: 不是特定用户
- **金额**: 各种金额都有

### 上下文

#### 相关代码
```python
# payment.py
class PaymentService:
    def charge(self, user, amount):
        """向支付网关发起收费"""
        endpoint = "/v1/charges"
        data = {
            "user_id": user.id,
            "amount": amount,
            "currency": "USD"
        }

        # 有重试机制
        for attempt in range(3):
            try:
                response = self._api_call(endpoint, data)
                return response.json()
            except PaymentError as e:
                if attempt == 2:
                    raise
                time.sleep(2 ** attempt)  # 指数退避

    def _api_call(self, endpoint, data):
        """调用第三方 API"""
        url = f"{self.base_url}{endpoint}"

        response = requests.post(
            url,
            json=data,
            headers=self._get_headers(),
            timeout=10
        )

        if response.status_code >= 500:
            raise PaymentError(f"API error: {response.status_code}")

        return response
```

#### 监控数据
```
支付网关健康状态:
- 最近 1 小时可用性: 99.5%
- 平均响应时间: 450ms
- P99 响应时间: 1200ms
- 错误率: 0.5%

我们的服务:
- 订单处理成功率: 99%
- 支付成功率: 98.5%
```

## 诊断要求

请深入分析：

### 1. 问题分类
- 这是偶发问题、系统性问题还是配置问题？
- 根因在哪里（我们的代码、第三方 API、网络）？

### 2. 可能原因
列出至少 3 种可能的原因，按概率排序。

### 3. 诊断步骤
提供具体的调试步骤：
1. 应该收集什么额外的日志？
2. 应该添加什么监控？
3. 如何缩小问题范围？

### 4. 临时解决方案
如果根因无法立即解决，如何缓解问题？

### 5. 长期解决方案
彻底解决问题的方案是什么？

### 6. 预防措施
如何防止类似问题再次发生？

## 输出格式

```markdown
# 问题诊断报告

## 问题总结
[一句话总结问题]

## 根因分析

### 最可能的原因（概率 70%）
**原因**: [详细描述]
**证据**: [支持这个原因的证据]
**验证方法**: [如何确认]

### 可能的原因 2（概率 20%）
...

### 可能的原因 3（概率 10%）
...

## 解决方案

### 立即行动（今天）
1. [行动项]
2. [行动项]

### 短期方案（本周）
1. [方案]
2. [方案]

### 长期方案（本月）
1. [方案]
2. [方案]

## 代码改进

### 问题代码
```python
[指出代码中的问题]
```

### 改进代码
```python
[改进后的代码]
```

### 改进说明
[解释为什么这样改进]

## 监控建议

### 新增监控
- [ ] [监控项 1]
- [ ] [监控项 2]

### 告警规则
- [ ] [告警条件]
- [ ] [通知方式]

## 经验教训
- [ ] [教训 1]
- [ ] [教训 2]
```
```

---

## 第三部分：提示调优技巧

### 技巧 1: 渐进式细化

**策略**: 从简单提示开始，逐步添加细节

**示例**:

#### V1: 基础版本
```
"写一个排序算法"
```

**评估**: 可能得到通用答案

#### V2: 添加语言和类型
```
"用 Python 写一个快速排序算法"
```

**评估**: 更接近目标

#### V3: 添加具体要求
```
"用 Python 写一个快速排序算法，要求：
- 处理整数列表
- 包含类型注解
- 添加文档字符串"
```

**评估**: 满意

### 技巧 2: A/B 测试

**策略**: 同时测试多个提示版本

**实施**:

```python
# prompt_versions.py
PROMPT_VERSIONS = {
    "v1": "基础提示词...",
    "v2": "添加上下文的提示词...",
    "v3": "添加示例的提示词...",
}

def test_prompt_version(version, test_cases):
    """测试特定版本的提示"""
    prompt = PROMPT_VERSIONS[version]
    results = []

    for case in test_cases:
        response = llm.complete(prompt + case["input"])
        results.append({
            "version": version,
            "case": case["name"],
            "output": response,
            "score": evaluate(response, case["expected"])
        })

    return results

# 比较不同版本
for version in ["v1", "v2", "v3"]:
    results = test_prompt_version(version, TEST_CASES)
    avg_score = sum(r["score"] for r in results) / len(results)
    print(f"{version}: 平均得分 {avg_score:.2f}")
```

### 技巧 3: 负面示例

**策略**: 明确告诉 LLM 什么**不**要做

**示例**:
```
请重构以下代码，但**不要**：

❌ 不改变函数签名（公共 API）
❌ 不改变现有行为（功能保持一致）
❌ 不添加新的依赖（仅使用标准库）
❌ 不牺牲可读性换取性能

**必须**：
✅ 保持所有测试通过
✅ 改进代码结构
✅ 提高可读性
✅ 添加必要注释
```

### 技巧 4: 约束引导

**策略**: 用约束引导 LLM 到正确的方向

**示例**:
```
请设计一个数据库模式，满足：

数据约束：
- 用户表：最多 100 万行
- 订单表：每年增长 500 万行
- 日志表：每天增长 10 万行

查询约束：
- 90% 的查询是用户的最近订单
- 需要支持复杂分析查询

性能约束：
- 查询响应时间 < 100ms (P95)
- 写入吞吐量 > 1000 ops/sec

请提供：
1. 表结构（包括索引）
2. 分区策略
3. 归档策略
```

### 技巧 5: 角色链

**策略**: 让 LLM 扮演多个角色，多角度审视问题

**示例**:
```
请完成以下任务，并从三个角色的角度审视：

## 角色 1: 资深开发者
关注：代码质量、架构设计、最佳实践

## 角色 2: 安全专家
关注：安全漏洞、数据保护、权限控制

## 角色 3: 产品经理
关注：用户需求、业务价值、可维护性

### 任务
[任务描述]

### 输出格式

#### 资深开发者的观点
[分析和建议]

#### 安全专家的观点
[分析和建议]

#### 产品经理的观点
[分析和建议]

#### 综合建议
[整合三个角色的观点，提供最终方案]
```

---

## 📊 知识检查

### 实践练习

1. **使用模板 1 生成代码**
   - 任务：实现一个二叉搜索树
   - 要求：插入、查找、删除操作

2. **使用模板 2 审查代码**
   - 找一段自己的代码
   - 按模板生成审查报告

3. **设计一个场景**
   - 选择你最近遇到的实际问题
   - 应用合适的模板
   - 评估效果

---

## 📚 延伸阅读

### 资源

1. [Anthropic Prompt Library](https://docs.anthropic.com/claude/prompt-library)
2. [OpenAI Cookbook](https://github.com/openai/openai-cookbook)
3. [Prompt Engineering Guide](https://www.promptingguide.ai/)

---

**下一阅读**: [AI Prompt Engineering: A Deep Dive](./04-ai-prompt-engineering-deep-dive.md)
