# AI ç¼–ç¨‹åŠ©æ‰‹æ‰©å±•æ–¹å‘

## æ¦‚è¿°

æœ¬æ‰©å±•æ–¹å‘ä¸“æ³¨äº**ä½¿ç”¨æ™ºèƒ½ä½“æŠ€æœ¯æ„å»ºæ™ºèƒ½ç¼–ç¨‹åŠ©æ‰‹**ï¼Œè¿™æ˜¯å½“å‰ AI é¢†åŸŸæœ€çƒ­é—¨çš„åº”ç”¨æ–¹å‘ä¹‹ä¸€ã€‚é€šè¿‡æœ¬æ–¹å‘çš„å­¦ä¹ ï¼Œä½ å°†æŒæ¡æ„å»ºç±»ä¼¼ GitHub Copilotã€Cursor ç­‰ AI ç¼–ç¨‹å·¥å…·çš„æ ¸å¿ƒæŠ€æœ¯ã€‚

## å­¦ä¹ è·¯å¾„

### é˜¶æ®µä¸€ï¼šåŸºç¡€ç†è§£ï¼ˆ1-2å‘¨ï¼‰

#### 1. ç¼–ç¨‹åŠ©æ‰‹çš„æ ¸å¿ƒèƒ½åŠ›

**ä»£ç ç”Ÿæˆ (Code Generation)**
```
ç”¨æˆ·è¾“å…¥ï¼šåˆ›å»ºä¸€ä¸ªå¿«é€Ÿæ’åºå‡½æ•°
AI è¾“å‡ºï¼šPython ä»£ç å®ç°

å…³é”®è¦ç´ ï¼š
- éœ€æ±‚ç†è§£ï¼ˆè‡ªç„¶è¯­è¨€ â†’ ç¼–ç¨‹æ„å›¾ï¼‰
- ä»£ç ç”Ÿæˆï¼ˆç¬¦åˆè¯­æ³•å’Œè§„èŒƒï¼‰
- å¤šè¯­è¨€æ”¯æŒï¼ˆPython, JavaScript, Java, etc.ï¼‰
- ä¸Šä¸‹æ–‡æ„ŸçŸ¥ï¼ˆåŸºäºç°æœ‰ä»£ç ï¼‰
```

**ä»£ç è¡¥å…¨ (Code Completion)**
```
åœºæ™¯ï¼šå¼€å‘è€…æ­£åœ¨è¾“å…¥ä»£ç 
AIï¼šé¢„æµ‹å¹¶è¡¥å…¨åç»­ä»£ç 

æŠ€æœ¯è¦ç‚¹ï¼š
- å®æ—¶é¢„æµ‹
- è¯­æ³•æ­£ç¡®æ€§
- è¯­ä¹‰åˆç†æ€§
- é£æ ¼ä¸€è‡´æ€§
```

**ä»£ç è§£é‡Š (Code Explanation)**
```
è¾“å…¥ï¼šä¸€æ®µä»£ç 
è¾“å‡ºï¼šè‡ªç„¶è¯­è¨€è§£é‡Š

åº”ç”¨åœºæ™¯ï¼š
- ä»£ç ç†è§£
- æ–‡æ¡£ç”Ÿæˆ
- æ•™å­¦è¾…åŠ©
```

#### 2. æŠ€æœ¯æ¶æ„æ¦‚è§ˆ

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          ç”¨æˆ·ç•Œé¢ (VSCode / CLI)         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        Agent ç¼–æ’å±‚ (Orchestrator)       â”‚
â”‚  - ä»»åŠ¡åˆ†è§£  - ä¸Šä¸‹æ–‡ç®¡ç†  - ç»“æœèšåˆ    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         æ ¸å¿ƒèƒ½åŠ›å±‚ (Capabilities)        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ä»£ç ç”Ÿæˆâ”‚ä»£ç å®¡æŸ¥â”‚æµ‹è¯•ç”Ÿæˆâ”‚æ–‡æ¡£ç”Ÿæˆâ”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         å·¥å…·å±‚ (Tools)                   â”‚
â”‚  - æ–‡ä»¶æ“ä½œ  - ASTè§£æ  - Gité›†æˆ        â”‚
â”‚  - LSPé›†æˆ   - æœç´¢å¼•æ“  - ç¼–è¯‘å™¨        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         åŸºç¡€æ¨¡å‹å±‚ (LLM)                 â”‚
â”‚  - GPT-4  - Claude  - ä»£ç ä¸“ç”¨æ¨¡å‹       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### é˜¶æ®µäºŒï¼šæ ¸å¿ƒåŠŸèƒ½å®ç°ï¼ˆ3-4å‘¨ï¼‰

#### é¡¹ç›®ä¸€ï¼šæ™ºèƒ½ä»£ç ç”ŸæˆåŠ©æ‰‹

**åŠŸèƒ½éœ€æ±‚**
1. ç†è§£è‡ªç„¶è¯­è¨€éœ€æ±‚
2. ç”Ÿæˆç¬¦åˆè§„èŒƒçš„ä»£ç 
3. æ”¯æŒå¤šç§ç¼–ç¨‹è¯­è¨€
4. æä¾›ä»£ç è§£é‡Š
5. æ”¯æŒè¿­ä»£ä¿®æ”¹

**æŠ€æœ¯å®ç°**

```python
class CodeGenerationAgent:
    """
    ä»£ç ç”Ÿæˆæ™ºèƒ½ä½“
    """
    def __init__(self, llm_client):
        self.llm = llm_client
        self.context_manager = ContextManager()
        self.code_validator = CodeValidator()

    def generate_code(self, requirement, language='python', context=None):
        """
        ç”Ÿæˆä»£ç 

        Args:
            requirement: è‡ªç„¶è¯­è¨€éœ€æ±‚
            language: ç›®æ ‡ç¼–ç¨‹è¯­è¨€
            context: ä»£ç ä¸Šä¸‹æ–‡ï¼ˆæ–‡ä»¶ã€é¡¹ç›®ç»“æ„ç­‰ï¼‰

        Returns:
            ç”Ÿæˆçš„ä»£ç å’Œè§£é‡Š
        """
        # 1. ç†è§£éœ€æ±‚
        parsed_requirement = self.parse_requirement(requirement)

        # 2. æ”¶é›†ä¸Šä¸‹æ–‡
        relevant_context = self.context_manager.get_context(context)

        # 3. æ„å»ºæç¤ºè¯
        prompt = self.build_generation_prompt(
            requirement=parsed_requirement,
            language=language,
            context=relevant_context
        )

        # 4. è°ƒç”¨ LLM ç”Ÿæˆ
        raw_code = self.llm.generate(prompt)

        # 5. éªŒè¯ä»£ç 
        validated_code = self.code_validator.validate(raw_code, language)

        # 6. ç”Ÿæˆè§£é‡Š
        explanation = self.generate_explanation(validated_code, language)

        return {
            'code': validated_code,
            'explanation': explanation,
            'language': language
        }

    def parse_requirement(self, requirement):
        """
        è§£æç”¨æˆ·éœ€æ±‚

        æå–å…³é”®ä¿¡æ¯ï¼š
        - åŠŸèƒ½æè¿°
        - è¾“å…¥è¾“å‡º
        - çº¦æŸæ¡ä»¶
        - ç‰¹æ®Šè¦æ±‚
        """
        prompt = f"""
        åˆ†æä»¥ä¸‹ç¼–ç¨‹éœ€æ±‚ï¼Œæå–å…³é”®ä¿¡æ¯ï¼š

        éœ€æ±‚ï¼š{requirement}

        è¯·ä»¥ JSON æ ¼å¼è¿”å›ï¼š
        {{
            "functionality": "ä¸»è¦åŠŸèƒ½",
            "inputs": ["è¾“å…¥å‚æ•°"],
            "outputs": ["è¾“å‡º"],
            "constraints": ["çº¦æŸæ¡ä»¶"],
            "language_hints": ["è¯­è¨€æç¤º"]
        }}
        """

        result = self.llm.generate(prompt)
        return json.loads(result)

    def build_generation_prompt(self, requirement, language, context):
        """
        æ„å»ºä»£ç ç”Ÿæˆæç¤ºè¯
        """
        prompt = f"""
ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„{language}ç¨‹åºå‘˜ã€‚è¯·æ ¹æ®ä»¥ä¸‹éœ€æ±‚ç¼–å†™ä»£ç ï¼š

## éœ€æ±‚è¯´æ˜
{requirement['functionality']}

## è¾“å…¥å‚æ•°
{json.dumps(requirement['inputs'], indent=2)}

## è¾“å‡ºè¦æ±‚
{json.dumps(requirement['outputs'], indent=2)}

## çº¦æŸæ¡ä»¶
{chr(10).join(requirement['constraints'])}

## ä»£ç ä¸Šä¸‹æ–‡
{context if context else 'æ— '}

## è¦æ±‚
1. ä»£ç å¿…é¡»ç¬¦åˆ{language}æœ€ä½³å®è·µ
2. æ·»åŠ å¿…è¦çš„æ³¨é‡Š
3. åŒ…å«é”™è¯¯å¤„ç†
4. è€ƒè™‘è¾¹ç•Œæƒ…å†µ
5. ä»£ç åº”è¯¥æ¸…æ™°æ˜“è¯»

è¯·ç”Ÿæˆä»£ç ï¼š
"""
        return prompt

    def refine_code(self, code, feedback):
        """
        æ ¹æ®åé¦ˆä¼˜åŒ–ä»£ç 

        Args:
            code: åŸå§‹ä»£ç 
            feedback: ç”¨æˆ·åé¦ˆ

        Returns:
            ä¼˜åŒ–åçš„ä»£ç 
        """
        prompt = f"""
åŸå§‹ä»£ç ï¼š
```python
{code}
```

ç”¨æˆ·åé¦ˆï¼š
{feedback}

è¯·æ ¹æ®åé¦ˆä¼˜åŒ–ä»£ç ã€‚ä¿æŒå…¶ä»–éƒ¨åˆ†ä¸å˜ã€‚
"""
        return self.llm.generate(prompt)


class ContextManager:
    """
    ä¸Šä¸‹æ–‡ç®¡ç†å™¨

    è´Ÿè´£æ”¶é›†å’Œç®¡ç†ä»£ç ä¸Šä¸‹æ–‡
    """
    def __init__(self):
        self.file_cache = {}
        self.ast_parser = ASTParser()

    def get_context(self, context_info):
        """
        è·å–ç›¸å…³ä¸Šä¸‹æ–‡

        ä¸Šä¸‹æ–‡åŒ…æ‹¬ï¼š
        - ç›¸å…³æ–‡ä»¶å†…å®¹
        - å‡½æ•°/ç±»å®šä¹‰
        - å¯¼å…¥çš„æ¨¡å—
        - é¡¹ç›®ç»“æ„
        """
        context_parts = []

        # æ–‡ä»¶å†…å®¹
        if context_info and 'file_path' in context_info:
            file_content = self.get_file_content(context_info['file_path'])
            context_parts.append(f"File: {context_info['file_path']}\n{file_content}")

        # ç›¸å…³å®šä¹‰
        if context_info and 'relevant_definitions' in context_info:
            definitions = self.get_definitions(context_info['relevant_definitions'])
            context_parts.append(f"\nRelevant Definitions:\n{definitions}")

        # é¡¹ç›®ç»“æ„
        if context_info and 'project_structure' in context_info:
            structure = self.format_structure(context_info['project_structure'])
            context_parts.append(f"\nProject Structure:\n{structure}")

        return "\n\n".join(context_parts)

    def get_file_content(self, file_path):
        """è·å–æ–‡ä»¶å†…å®¹"""
        if file_path not in self.file_cache:
            with open(file_path, 'r') as f:
                self.file_cache[file_path] = f.read()
        return self.file_cache[file_path]

    def get_definitions(self, definition_names):
        """è·å–å‡½æ•°/ç±»å®šä¹‰"""
        definitions = []
        for name in definition_names:
            # ä» AST ä¸­æå–å®šä¹‰
            def_code = self.ast_parser.get_definition(name)
            if def_code:
                definitions.append(def_code)
        return "\n\n".join(definitions)


class CodeValidator:
    """
    ä»£ç éªŒè¯å™¨

    éªŒè¯ç”Ÿæˆçš„ä»£ç æ˜¯å¦æ­£ç¡®
    """
    def __init__(self):
        self.syntax_checkers = {
            'python': self.check_python_syntax,
            'javascript': self.check_js_syntax,
            # å…¶ä»–è¯­è¨€...
        }

    def validate(self, code, language):
        """
        éªŒè¯ä»£ç 

        1. è¯­æ³•æ£€æŸ¥
        2. åŸºæœ¬å®‰å…¨æ£€æŸ¥
        3. æ ¼å¼åŒ–
        """
        # è¯­æ³•æ£€æŸ¥
        if language in self.syntax_checkers:
            is_valid, error = self.syntax_checkers[language](code)
            if not is_valid:
                # å°è¯•ä¿®å¤è¯­æ³•é”™è¯¯
                code = self.fix_syntax(code, language, error)

        # å®‰å…¨æ£€æŸ¥
        code = self.security_check(code)

        # æ ¼å¼åŒ–
        code = self.format_code(code, language)

        return code

    def check_python_syntax(self, code):
        """æ£€æŸ¥ Python è¯­æ³•"""
        try:
            compile(code, '<string>', 'exec')
            return True, None
        except SyntaxError as e:
            return False, str(e)

    def security_check(self, code):
        """
        å®‰å…¨æ£€æŸ¥

        æ£€æµ‹å±é™©æ“ä½œï¼š
        - eval/exec
        - æ–‡ä»¶æ“ä½œ
        - ç½‘ç»œè¯·æ±‚
        - ç³»ç»Ÿå‘½ä»¤
        """
        dangerous_patterns = [
            r'\beval\s*\(',
            r'\bexec\s*\(',
            r'\bos\.system\s*\(',
            r'\bsubprocess\.'
        ]

        safe_code = code
        for pattern in dangerous_patterns:
            if re.search(pattern, code):
                # æ·»åŠ è­¦å‘Šæ³¨é‡Š
                safe_code = f"# WARNING: Potentially dangerous operation detected\n{safe_code}"

        return safe_code
```

#### é¡¹ç›®äºŒï¼šæ™ºèƒ½ä»£ç å®¡æŸ¥ç³»ç»Ÿ

**åŠŸèƒ½éœ€æ±‚**
1. åˆ†æä»£ç è´¨é‡
2. æ£€æµ‹å®‰å…¨æ¼æ´
3. æä¾›ä¼˜åŒ–å»ºè®®
4. æ£€æŸ¥æœ€ä½³å®è·µ
5. ç”Ÿæˆå®¡æŸ¥æŠ¥å‘Š

**æŠ€æœ¯å®ç°**

```python
class CodeReviewAgent:
    """
    ä»£ç å®¡æŸ¥æ™ºèƒ½ä½“
    """
    def __init__(self, llm_client):
        self.llm = llm_client
        self.issue_detector = IssueDetector()
        self.security_scanner = SecurityScanner()
        self.best_practices_checker = BestPracticesChecker()

    def review_code(self, code, language='python', context=None):
        """
        å®¡æŸ¥ä»£ç 

        Returns:
            å®¡æŸ¥æŠ¥å‘Š
        """
        report = {
            'issues': [],
            'security_issues': [],
            'optimizations': [],
            'best_practices': [],
            'overall_score': 0,
            'summary': ''
        }

        # 1. æ£€æµ‹é—®é¢˜
        issues = self.issue_detector.detect(code, language)
        report['issues'] = issues

        # 2. å®‰å…¨æ‰«æ
        security_issues = self.security_scanner.scan(code, language)
        report['security_issues'] = security_issues

        # 3. ä¼˜åŒ–å»ºè®®
        optimizations = self.suggest_optimizations(code, language)
        report['optimizations'] = optimizations

        # 4. æœ€ä½³å®è·µæ£€æŸ¥
        practices = self.best_practices_checker.check(code, language)
        report['best_practices'] = practices

        # 5. è®¡ç®—æ€»åˆ†
        report['overall_score'] = self.calculate_score(report)

        # 6. ç”Ÿæˆæ‘˜è¦
        report['summary'] = self.generate_summary(report)

        return report

    def suggest_optimizations(self, code, language):
        """
        ä¼˜åŒ–å»ºè®®

        ä½¿ç”¨ LLM åˆ†æä»£ç ï¼Œæä¾›ä¼˜åŒ–å»ºè®®
        """
        prompt = f"""
åˆ†æä»¥ä¸‹{language}ä»£ç ï¼Œæä¾›æ€§èƒ½ä¼˜åŒ–å»ºè®®ï¼š

```{language}
{code}
```

è¯·ä»ä»¥ä¸‹æ–¹é¢åˆ†æï¼š
1. æ—¶é—´å¤æ‚åº¦ä¼˜åŒ–
2. ç©ºé—´å¤æ‚åº¦ä¼˜åŒ–
3. ç®—æ³•é€‰æ‹©
4. æ•°æ®ç»“æ„é€‰æ‹©
5. æƒ°æ€§è®¡ç®—æœºä¼š
6. å¹¶è¡ŒåŒ–æœºä¼š

è¿”å› JSON æ ¼å¼çš„å»ºè®®åˆ—è¡¨ã€‚
"""
        response = self.llm.generate(prompt)
        return json.loads(response)

    def generate_summary(self, report):
        """
        ç”Ÿæˆå®¡æŸ¥æ‘˜è¦
        """
        issue_count = len(report['issues'])
        security_count = len(report['security_issues'])
        optimization_count = len(report['optimizations'])

        prompt = f"""
åŸºäºä»¥ä¸‹å®¡æŸ¥æ•°æ®ï¼Œç”Ÿæˆä¸€ä»½ç®€æ´çš„ä»£ç å®¡æŸ¥æ‘˜è¦ï¼š

- å‘ç°é—®é¢˜æ•°ï¼š{issue_count}
- å®‰å…¨é—®é¢˜æ•°ï¼š{security_count}
- ä¼˜åŒ–å»ºè®®æ•°ï¼š{optimization_count}
- æ€»ä½“è¯„åˆ†ï¼š{report['overall_score']}/100

é—®é¢˜åˆ—è¡¨ï¼š
{json.dumps(report['issues'][:5], indent=2)}

å®‰å…¨é£é™©ï¼š
{json.dumps(report['security_issues'][:5], indent=2)}

è¯·ç”Ÿæˆä¸“ä¸šã€å»ºè®¾æ€§çš„å®¡æŸ¥æ‘˜è¦ã€‚
"""
        return self.llm.generate(prompt)


class IssueDetector:
    """
    é—®é¢˜æ£€æµ‹å™¨

    ä½¿ç”¨é™æ€åˆ†æå’Œ LLM æ£€æµ‹ä»£ç é—®é¢˜
    """
    def detect(self, code, language):
        """
        æ£€æµ‹ä»£ç é—®é¢˜

        é—®é¢˜ç±»å‹ï¼š
        - è¯­æ³•é”™è¯¯
        - é€»è¾‘é”™è¯¯
        - è¾¹ç•Œæƒ…å†µ
        - é”™è¯¯å¤„ç†ç¼ºå¤±
        """
        issues = []

        # ä½¿ç”¨ LLM æ£€æµ‹
        llm_issues = self.llm_detect(code, language)
        issues.extend(llm_issues)

        # é™æ€åˆ†æ
        static_issues = self.static_analyze(code, language)
        issues.extend(static_issues)

        return issues

    def llm_detect(self, code, language):
        """
        ä½¿ç”¨ LLM æ£€æµ‹é—®é¢˜
        """
        prompt = f"""
ä»”ç»†å®¡æŸ¥ä»¥ä¸‹{language}ä»£ç ï¼Œæ‰¾å‡ºæ‰€æœ‰æ½œåœ¨é—®é¢˜ï¼š

```{language}
{code}
```

æ£€æŸ¥é¡¹ï¼š
1. é€»è¾‘é”™è¯¯
2. è¾¹ç•Œæƒ…å†µå¤„ç†
3. é”™è¯¯å¤„ç†
4. èµ„æºæ³„æ¼
5. å¹¶å‘é—®é¢˜
6. æ€§èƒ½é—®é¢˜

è¿”å› JSON æ ¼å¼çš„é—®é¢˜åˆ—è¡¨ï¼Œæ¯ä¸ªé—®é¢˜åŒ…å«ï¼š
- type: é—®é¢˜ç±»å‹
- severity: ä¸¥é‡ç¨‹åº¦ (low/medium/high/critical)
- location: ä½ç½®
- description: æè¿°
- suggestion: ä¿®å¤å»ºè®®
"""
        response = self.llm.generate(prompt)
        return json.loads(response)


class SecurityScanner:
    """
    å®‰å…¨æ‰«æå™¨

    æ£€æµ‹å®‰å…¨æ¼æ´å’Œé£é™©
    """
    # å·²çŸ¥æ¼æ´æ¨¡å¼
    VULNERABILITY_PATTERNS = {
        'sql_injection': [
            r'f"SELECT.*FROM.*WHERE.*{user_input}"',
            r'"SELECT.*FROM.*WHERE.*\+".*user_input',
        ],
        'xss': [
            r'innerHTML\s*=\s*.*user_input',
            r'document\.write\s*\(.*user_input',
        ],
        'hardcoded_secrets': [
            r'password\s*=\s*["\'][^"\']+["\']',
            r'api_key\s*=\s*["\'][^"\']+["\']',
        ],
        'insecure_random': [
            r'random\.random\(\)',  # ä¸åº”ç”¨äºå®‰å…¨ç›¸å…³
        ]
    }

    def scan(self, code, language):
        """
        æ‰«æå®‰å…¨æ¼æ´
        """
        vulnerabilities = []

        for vuln_type, patterns in self.VULNERABILITY_PATTERNS.items():
            for pattern in patterns:
                matches = re.finditer(pattern, code, re.MULTILINE)
                for match in matches:
                    vulnerabilities.append({
                        'type': vuln_type,
                        'severity': 'high',
                        'location': self.get_location(code, match.start()),
                        'code_snippet': match.group(),
                        'description': self.get_description(vuln_type),
                        'remediation': self.get_remediation(vuln_type)
                    })

        # ä½¿ç”¨ LLM è¿›è¡Œæ·±åº¦åˆ†æ
        llm_vulns = self.llm_security_scan(code, language)
        vulnerabilities.extend(llm_vulns)

        return vulnerabilities
```

#### é¡¹ç›®ä¸‰ï¼šè‡ªåŠ¨åŒ–æµ‹è¯•ç”Ÿæˆå™¨

**åŠŸèƒ½éœ€æ±‚**
1. è‡ªåŠ¨ç”Ÿæˆå•å…ƒæµ‹è¯•
2. ç”Ÿæˆæµ‹è¯•ç”¨ä¾‹æ•°æ®
3. è¦†ç›–è¾¹ç•Œæƒ…å†µ
4. ç”Ÿæˆ Mock æ•°æ®
5. ç”Ÿæˆæµ‹è¯•æŠ¥å‘Š

**æŠ€æœ¯å®ç°**

```python
class TestGenerationAgent:
    """
    æµ‹è¯•ç”Ÿæˆæ™ºèƒ½ä½“
    """
    def __init__(self, llm_client):
        self.llm = llm_client
        self.mock_generator = MockDataGenerator()
        self.coverage_analyzer = CoverageAnalyzer()

    def generate_tests(self, code, language='python'):
        """
        ç”Ÿæˆæµ‹è¯•ä»£ç 

        Returns:
            æµ‹è¯•ä»£ç å’Œæµ‹è¯•è¯´æ˜
        """
        # 1. åˆ†æä»£ç ç»“æ„
        code_structure = self.analyze_structure(code, language)

        # 2. ä¸ºæ¯ä¸ªå‡½æ•°ç”Ÿæˆæµ‹è¯•
        tests = []
        for function in code_structure['functions']:
            function_tests = self.generate_function_tests(function, language)
            tests.extend(function_tests)

        # 3. ç”Ÿæˆæµ‹è¯•å¥—ä»¶
        test_suite = self.assemble_test_suite(tests, language)

        # 4. ç”Ÿæˆ Mock æ•°æ®
        mock_data = self.mock_generator.generate(code_structure)

        return {
            'test_code': test_suite,
            'mock_data': mock_data,
            'test_cases': tests,
            'coverage_target': self.calculate_coverage_target(code_structure)
        }

    def generate_function_tests(self, function, language):
        """
        ä¸ºå•ä¸ªå‡½æ•°ç”Ÿæˆæµ‹è¯•
        """
        test_cases = []

        # æ­£å¸¸æƒ…å†µ
        normal_cases = self.generate_normal_cases(function, language)
        test_cases.extend(normal_cases)

        # è¾¹ç•Œæƒ…å†µ
        edge_cases = self.generate_edge_cases(function, language)
        test_cases.extend(edge_cases)

        # å¼‚å¸¸æƒ…å†µ
        error_cases = self.generate_error_cases(function, language)
        test_cases.extend(error_cases)

        return test_cases

    def generate_normal_cases(self, function, language):
        """
        ç”Ÿæˆæ­£å¸¸æƒ…å†µæµ‹è¯•
        """
        prompt = f"""
ä¸ºä»¥ä¸‹å‡½æ•°ç”Ÿæˆæ­£å¸¸æƒ…å†µæµ‹è¯•ç”¨ä¾‹ï¼š

å‡½æ•°åï¼š{function['name']}
å‚æ•°ï¼š{json.dumps(function['parameters'], indent=2)}
è¿”å›å€¼ï¼š{function['return_type']}
åŠŸèƒ½æè¿°ï¼š{function.get('description', 'æœªçŸ¥')}

è¦æ±‚ï¼š
1. ç”Ÿæˆ 3-5 ä¸ªä»£è¡¨æ€§æµ‹è¯•ç”¨ä¾‹
2. è¦†ç›–å…¸å‹ä½¿ç”¨åœºæ™¯
3. åŒ…å«è¾“å…¥å’Œé¢„æœŸè¾“å‡º

è¿”å› JSON æ ¼å¼ã€‚
"""
        response = self.llm.generate(prompt)
        return json.loads(response)

    def generate_edge_cases(self, function, language):
        """
        ç”Ÿæˆè¾¹ç•Œæƒ…å†µæµ‹è¯•
        """
        prompt = f"""
ä¸ºä»¥ä¸‹å‡½æ•°ç”Ÿæˆè¾¹ç•Œæƒ…å†µæµ‹è¯•ç”¨ä¾‹ï¼š

å‡½æ•°åï¼š{function['name']}
å‚æ•°ï¼š{json.dumps(function['parameters'], indent=2)}

è¾¹ç•Œæƒ…å†µè€ƒè™‘ï¼š
- ç©ºå€¼/None
- æœ€å°å€¼/æœ€å¤§å€¼
- ç©ºé›†åˆ/å•å…ƒç´ é›†åˆ
- å­—ç¬¦ä¸²ï¼šç©ºå­—ç¬¦ä¸²ã€æé•¿å­—ç¬¦ä¸²
- æ•°å€¼ï¼š0ã€è´Ÿæ•°ã€æµ®ç‚¹æ•°ç²¾åº¦

è¿”å› JSON æ ¼å¼çš„æµ‹è¯•ç”¨ä¾‹åˆ—è¡¨ã€‚
"""
        response = self.llm.generate(prompt)
        return json.loads(response)

    def assemble_test_suite(self, test_cases, language):
        """
        ç»„è£…æµ‹è¯•å¥—ä»¶
        """
        if language == 'python':
            return self.assemble_python_tests(test_cases)
        elif language == 'javascript':
            return self.assemble_js_tests(test_cases)
        # å…¶ä»–è¯­è¨€...

    def assemble_python_tests(self, test_cases):
        """
        ç»„è£… Python æµ‹è¯•ä»£ç 
        """
        test_code = """
import unittest
from unittest.mock import patch, Mock
import pytest

class GeneratedTests(unittest.TestCase):

"""

        for i, test_case in enumerate(test_cases):
            test_code += f"""
    def test_{test_case['name']}_{i}(self):
        \"\"\"
        {test_case.get('description', '')}
        \"\"\"
        # Arrange
        {self.format_test_setup(test_case)}

        # Act
        {self.format_test_action(test_case)}

        # Assert
        {self.format_test_assertion(test_case)}

"""

        return test_code
```

### é˜¶æ®µä¸‰ï¼šé«˜çº§åŠŸèƒ½ï¼ˆ2-3å‘¨ï¼‰

#### é¡¹ç›®å››ï¼šæ™ºèƒ½è°ƒè¯•åŠ©æ‰‹

```python
class DebuggingAgent:
    """
    è°ƒè¯•æ™ºèƒ½ä½“

    åŠŸèƒ½ï¼š
    - åˆ†æé”™è¯¯æ—¥å¿—
    - å®šä½ Bug ä½ç½®
    - è§£é‡Šé”™è¯¯åŸå› 
    - æä¾›ä¿®å¤æ–¹æ¡ˆ
    """
    def debug(self, error_info, code_context):
        """
        è°ƒè¯•é”™è¯¯

        Args:
            error_info: é”™è¯¯ä¿¡æ¯ï¼ˆå †æ ˆè·Ÿè¸ªã€é”™è¯¯æ¶ˆæ¯ç­‰ï¼‰
            code_context: ç›¸å…³ä»£ç 

        Returns:
            è°ƒè¯•åˆ†ææŠ¥å‘Š
        """
        # 1. åˆ†æé”™è¯¯ç±»å‹
        error_type = self.classify_error(error_info)

        # 2. å®šä½é”™è¯¯ä½ç½®
        error_location = self.locate_error(error_info, code_context)

        # 3. åˆ†æé”™è¯¯åŸå› 
        root_cause = self.analyze_cause(error_info, code_context, error_location)

        # 4. æä¾›ä¿®å¤æ–¹æ¡ˆ
        fixes = self.suggest_fixes(root_cause, code_context, error_location)

        return {
            'error_type': error_type,
            'location': error_location,
            'cause': root_cause,
            'fixes': fixes,
            'prevention_tips': self.get_prevention_tips(error_type)
        }
```

#### é¡¹ç›®äº”ï¼šä»£ç é‡æ„åŠ©æ‰‹

```python
class RefactoringAgent:
    """
    é‡æ„æ™ºèƒ½ä½“

    åŠŸèƒ½ï¼š
    - è¯†åˆ«ä»£ç å¼‚å‘³
    - å»ºè®®é‡æ„æ–¹æ¡ˆ
    - è‡ªåŠ¨é‡æ„
    - ä¿æŒæµ‹è¯•é€šè¿‡
    """
    def suggest_refactorings(self, code, language):
        """
        å»ºè®®é‡æ„æ–¹æ¡ˆ

        é‡æ„ç±»å‹ï¼š
        - æå–å‡½æ•°
        - æå–å˜é‡
        - å†…è”å‡½æ•°
        - é‡å‘½å
        - æ”¹å˜å‡½æ•°ç­¾å
        """
        prompt = f"""
åˆ†æä»¥ä¸‹ä»£ç ï¼Œæä¾›é‡æ„å»ºè®®ï¼š

```{language}
{code}
```

æ£€æŸ¥ï¼š
1. å‡½æ•°è¿‡é•¿
2. é‡å¤ä»£ç 
3. å¤æ‚æ¡ä»¶
4. é­”æ³•æ•°å­—
5. ä¸å¥½çš„å‘½å
6. èŒè´£ä¸æ¸…

è¿”å› JSON æ ¼å¼çš„é‡æ„å»ºè®®åˆ—è¡¨ã€‚
"""
        response = self.llm.generate(prompt)
        return json.loads(response)
```

### é˜¶æ®µå››ï¼šç³»ç»Ÿé›†æˆï¼ˆ1-2å‘¨ï¼‰

#### å®Œæ•´çš„ç¼–ç¨‹åŠ©æ‰‹ç³»ç»Ÿ

```python
class AICodingAssistant:
    """
    å®Œæ•´çš„ AI ç¼–ç¨‹åŠ©æ‰‹

    æ•´åˆæ‰€æœ‰åŠŸèƒ½
    """
    def __init__(self, llm_client):
        # åˆå§‹åŒ–å„ä¸ªæ™ºèƒ½ä½“
        self.code_generator = CodeGenerationAgent(llm_client)
        self.code_reviewer = CodeReviewAgent(llm_client)
        self.test_generator = TestGenerationAgent(llm_client)
        self.debugger = DebuggingAgent(llm_client)
        self.refactoring_agent = RefactoringAgent(llm_client)

        # å·¥ä½œæµç¼–æ’
        self.orchestrator = WorkflowOrchestrator()

    def process_request(self, user_request, context):
        """
        å¤„ç†ç”¨æˆ·è¯·æ±‚

        æ™ºèƒ½è·¯ç”±åˆ°åˆé€‚çš„æ™ºèƒ½ä½“
        """
        # åˆ†æè¯·æ±‚ç±»å‹
        intent = self.classify_intent(user_request)

        if intent == 'generate':
            return self.code_generator.generate_code(user_request, context)
        elif intent == 'review':
            return self.code_reviewer.review_code(user_request, context)
        elif intent == 'test':
            return self.test_generator.generate_tests(user_request, context)
        elif intent == 'debug':
            return self.debugger.debug(user_request, context)
        elif intent == 'refactor':
            return self.refactoring_agent.suggest_refactorings(user_request, context)
        else:
            # å¤æ‚è¯·æ±‚ï¼Œä½¿ç”¨å¤šæ™ºèƒ½ä½“åä½œ
            return self.orchestrator.process_complex_request(user_request, context)
```

## å®é™…é¡¹ç›®å»ºè®®

### åˆçº§é¡¹ç›®
1. **ç®€å•ä»£ç ç”Ÿæˆå™¨**
   - CLI å·¥å…·
   - æ”¯æŒå•ä¸ªå‡½æ•°ç”Ÿæˆ
   - Python è¯­è¨€

2. **ä»£ç è§£é‡Šå™¨**
   - è¾“å…¥ä»£ç ï¼Œè¾“å‡ºè§£é‡Š
   - æ”¯æŒå¤šè¯­è¨€

### ä¸­çº§é¡¹ç›®
3. **VSCode æ‰©å±•**
   - ä»£ç è¡¥å…¨
   - ä»£ç è§£é‡Š
   - ç®€å•å®¡æŸ¥

4. **æµ‹è¯•ç”Ÿæˆå·¥å…·**
   - è‡ªåŠ¨ç”Ÿæˆå•å…ƒæµ‹è¯•
   - æ”¯æŒä¸»æµæµ‹è¯•æ¡†æ¶

### é«˜çº§é¡¹ç›®
5. **å®Œæ•´ç¼–ç¨‹åŠ©æ‰‹**
   - VSCode / JetBrains æ’ä»¶
   - æ•´åˆå¤šé¡¹åŠŸèƒ½
   - é¡¹ç›®çº§ä¸Šä¸‹æ–‡ç†è§£

6. **ä»£ç å®¡æŸ¥ Bot**
   - GitHub/GitLab é›†æˆ
   - PR è‡ªåŠ¨å®¡æŸ¥
   - CI/CD é›†æˆ

## å­¦ä¹ èµ„æº

### è®ºæ–‡å’Œæ–‡æ¡£
- "Codex: Evaluating Large Language Models Trained on Code"
- "Program Synthesis with Large Language Models"
- GitHub Copilot æŠ€æœ¯åšå®¢

### å¼€æºé¡¹ç›®
- Continue
- CodeGeeX
- StarCoder
- Tabby

### å·¥å…·å’Œæ¡†æ¶
- LangChain
- LlamaIndex
- Tree-sitter (AST è§£æ)
- Pygments (ä»£ç é«˜äº®)

## èŒä¸šæ–¹å‘

æŒæ¡ AI ç¼–ç¨‹åŠ©æ‰‹æŠ€æœ¯åï¼Œä½ å¯ä»¥ä»äº‹ï¼š

1. **AI å·¥å…·å¼€å‘**
   - GitHub, Microsoft, JetBrains
   - åˆ›ä¸šå…¬å¸

2. **å¼€å‘è€…å·¥å…·**
   - IDE æ’ä»¶å¼€å‘
   - CI/CD å·¥å…·

3. **ç ”å‘æ•ˆèƒ½**
   - ä»£ç è´¨é‡å¹³å°
   - è‡ªåŠ¨åŒ–æµ‹è¯•å¹³å°

4. **æŠ€æœ¯å’¨è¯¢**
   - AI è¾…åŠ©å¼€å‘
   - ç ”å‘æ•ˆç‡æå‡

å¼€å§‹ä½ çš„ AI ç¼–ç¨‹åŠ©æ‰‹å­¦ä¹ ä¹‹æ—…å§ï¼ ğŸš€
